// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.6.1
// source: gpio.proto

package gpio

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Gpio_Open_FullMethodName         = "/gpio.Gpio/Open"
	Gpio_Close_FullMethodName        = "/gpio.Gpio/Close"
	Gpio_Input_FullMethodName        = "/gpio.Gpio/Input"
	Gpio_Output_FullMethodName       = "/gpio.Gpio/Output"
	Gpio_Clock_FullMethodName        = "/gpio.Gpio/Clock"
	Gpio_Pwm_FullMethodName          = "/gpio.Gpio/Pwm"
	Gpio_PullUp_FullMethodName       = "/gpio.Gpio/PullUp"
	Gpio_PullDown_FullMethodName     = "/gpio.Gpio/PullDown"
	Gpio_PullOff_FullMethodName      = "/gpio.Gpio/PullOff"
	Gpio_High_FullMethodName         = "/gpio.Gpio/High"
	Gpio_Low_FullMethodName          = "/gpio.Gpio/Low"
	Gpio_Toggle_FullMethodName       = "/gpio.Gpio/Toggle"
	Gpio_Write_FullMethodName        = "/gpio.Gpio/Write"
	Gpio_Read_FullMethodName         = "/gpio.Gpio/Read"
	Gpio_Freq_FullMethodName         = "/gpio.Gpio/Freq"
	Gpio_DutyCycle_FullMethodName    = "/gpio.Gpio/DutyCycle"
	Gpio_Detect_FullMethodName       = "/gpio.Gpio/Detect"
	Gpio_EdgeDetected_FullMethodName = "/gpio.Gpio/EdgeDetected"
)

// GpioClient is the client API for Gpio service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GpioClient interface {
	// Init / Shutdown
	Open(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	Close(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error)
	// Pin Modes
	Input(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	Output(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	Clock(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	Pwm(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	PullUp(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	PullDown(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	PullOff(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	// Basic pin operations
	High(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	Low(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	Toggle(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error)
	Write(ctx context.Context, in *RequestWrite, opts ...grpc.CallOption) (*Void, error)
	Read(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*ResponseRead, error)
	// Clock and PWM operations
	Freq(ctx context.Context, in *RequestFreq, opts ...grpc.CallOption) (*Void, error)
	DutyCycle(ctx context.Context, in *RequestDutyCycle, opts ...grpc.CallOption) (*Void, error)
	// Edge detection
	Detect(ctx context.Context, in *RequestEdgeDetect, opts ...grpc.CallOption) (*Void, error)
	EdgeDetected(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*ResponseEdgeDetected, error)
}

type gpioClient struct {
	cc grpc.ClientConnInterface
}

func NewGpioClient(cc grpc.ClientConnInterface) GpioClient {
	return &gpioClient{cc}
}

func (c *gpioClient) Open(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Open_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Close(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Close_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Input(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Input_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Output(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Output_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Clock(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Clock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Pwm(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Pwm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) PullUp(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_PullUp_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) PullDown(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_PullDown_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) PullOff(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_PullOff_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) High(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_High_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Low(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Low_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Toggle(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Toggle_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Write(ctx context.Context, in *RequestWrite, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Write_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Read(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*ResponseRead, error) {
	out := new(ResponseRead)
	err := c.cc.Invoke(ctx, Gpio_Read_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Freq(ctx context.Context, in *RequestFreq, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Freq_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) DutyCycle(ctx context.Context, in *RequestDutyCycle, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_DutyCycle_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) Detect(ctx context.Context, in *RequestEdgeDetect, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, Gpio_Detect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gpioClient) EdgeDetected(ctx context.Context, in *GpioPin, opts ...grpc.CallOption) (*ResponseEdgeDetected, error) {
	out := new(ResponseEdgeDetected)
	err := c.cc.Invoke(ctx, Gpio_EdgeDetected_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GpioServer is the server API for Gpio service.
// All implementations must embed UnimplementedGpioServer
// for forward compatibility
type GpioServer interface {
	// Init / Shutdown
	Open(context.Context, *Void) (*Void, error)
	Close(context.Context, *Void) (*Void, error)
	// Pin Modes
	Input(context.Context, *GpioPin) (*Void, error)
	Output(context.Context, *GpioPin) (*Void, error)
	Clock(context.Context, *GpioPin) (*Void, error)
	Pwm(context.Context, *GpioPin) (*Void, error)
	PullUp(context.Context, *GpioPin) (*Void, error)
	PullDown(context.Context, *GpioPin) (*Void, error)
	PullOff(context.Context, *GpioPin) (*Void, error)
	// Basic pin operations
	High(context.Context, *GpioPin) (*Void, error)
	Low(context.Context, *GpioPin) (*Void, error)
	Toggle(context.Context, *GpioPin) (*Void, error)
	Write(context.Context, *RequestWrite) (*Void, error)
	Read(context.Context, *GpioPin) (*ResponseRead, error)
	// Clock and PWM operations
	Freq(context.Context, *RequestFreq) (*Void, error)
	DutyCycle(context.Context, *RequestDutyCycle) (*Void, error)
	// Edge detection
	Detect(context.Context, *RequestEdgeDetect) (*Void, error)
	EdgeDetected(context.Context, *GpioPin) (*ResponseEdgeDetected, error)
	mustEmbedUnimplementedGpioServer()
}

// UnimplementedGpioServer must be embedded to have forward compatible implementations.
type UnimplementedGpioServer struct {
}

func (UnimplementedGpioServer) Open(context.Context, *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Open not implemented")
}
func (UnimplementedGpioServer) Close(context.Context, *Void) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedGpioServer) Input(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Input not implemented")
}
func (UnimplementedGpioServer) Output(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedGpioServer) Clock(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clock not implemented")
}
func (UnimplementedGpioServer) Pwm(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pwm not implemented")
}
func (UnimplementedGpioServer) PullUp(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullUp not implemented")
}
func (UnimplementedGpioServer) PullDown(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullDown not implemented")
}
func (UnimplementedGpioServer) PullOff(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullOff not implemented")
}
func (UnimplementedGpioServer) High(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method High not implemented")
}
func (UnimplementedGpioServer) Low(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Low not implemented")
}
func (UnimplementedGpioServer) Toggle(context.Context, *GpioPin) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Toggle not implemented")
}
func (UnimplementedGpioServer) Write(context.Context, *RequestWrite) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (UnimplementedGpioServer) Read(context.Context, *GpioPin) (*ResponseRead, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedGpioServer) Freq(context.Context, *RequestFreq) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Freq not implemented")
}
func (UnimplementedGpioServer) DutyCycle(context.Context, *RequestDutyCycle) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DutyCycle not implemented")
}
func (UnimplementedGpioServer) Detect(context.Context, *RequestEdgeDetect) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedGpioServer) EdgeDetected(context.Context, *GpioPin) (*ResponseEdgeDetected, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EdgeDetected not implemented")
}
func (UnimplementedGpioServer) mustEmbedUnimplementedGpioServer() {}

// UnsafeGpioServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GpioServer will
// result in compilation errors.
type UnsafeGpioServer interface {
	mustEmbedUnimplementedGpioServer()
}

func RegisterGpioServer(s grpc.ServiceRegistrar, srv GpioServer) {
	s.RegisterService(&Gpio_ServiceDesc, srv)
}

func _Gpio_Open_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Open(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Open_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Open(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Close_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Close(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Input_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Input(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Input_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Input(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Output_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Output(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Clock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Clock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Clock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Clock(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Pwm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Pwm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Pwm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Pwm(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_PullUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).PullUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_PullUp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).PullUp(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_PullDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).PullDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_PullDown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).PullDown(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_PullOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).PullOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_PullOff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).PullOff(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_High_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).High(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_High_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).High(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Low_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Low(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Low_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Low(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Toggle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Toggle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Toggle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Toggle(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestWrite)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Write_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Write(ctx, req.(*RequestWrite))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Read_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Read(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Freq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFreq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Freq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Freq_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Freq(ctx, req.(*RequestFreq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_DutyCycle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDutyCycle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).DutyCycle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_DutyCycle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).DutyCycle(ctx, req.(*RequestDutyCycle))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEdgeDetect)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_Detect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).Detect(ctx, req.(*RequestEdgeDetect))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gpio_EdgeDetected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpioPin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GpioServer).EdgeDetected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gpio_EdgeDetected_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GpioServer).EdgeDetected(ctx, req.(*GpioPin))
	}
	return interceptor(ctx, in, info, handler)
}

// Gpio_ServiceDesc is the grpc.ServiceDesc for Gpio service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gpio_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gpio.Gpio",
	HandlerType: (*GpioServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Open",
			Handler:    _Gpio_Open_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _Gpio_Close_Handler,
		},
		{
			MethodName: "Input",
			Handler:    _Gpio_Input_Handler,
		},
		{
			MethodName: "Output",
			Handler:    _Gpio_Output_Handler,
		},
		{
			MethodName: "Clock",
			Handler:    _Gpio_Clock_Handler,
		},
		{
			MethodName: "Pwm",
			Handler:    _Gpio_Pwm_Handler,
		},
		{
			MethodName: "PullUp",
			Handler:    _Gpio_PullUp_Handler,
		},
		{
			MethodName: "PullDown",
			Handler:    _Gpio_PullDown_Handler,
		},
		{
			MethodName: "PullOff",
			Handler:    _Gpio_PullOff_Handler,
		},
		{
			MethodName: "High",
			Handler:    _Gpio_High_Handler,
		},
		{
			MethodName: "Low",
			Handler:    _Gpio_Low_Handler,
		},
		{
			MethodName: "Toggle",
			Handler:    _Gpio_Toggle_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _Gpio_Write_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Gpio_Read_Handler,
		},
		{
			MethodName: "Freq",
			Handler:    _Gpio_Freq_Handler,
		},
		{
			MethodName: "DutyCycle",
			Handler:    _Gpio_DutyCycle_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _Gpio_Detect_Handler,
		},
		{
			MethodName: "EdgeDetected",
			Handler:    _Gpio_EdgeDetected_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gpio.proto",
}
